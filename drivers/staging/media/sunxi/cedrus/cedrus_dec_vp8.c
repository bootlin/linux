// SPDX-License-Identifier: GPL-2.0-or-later
/*
 * Cedrus Video Engine Driver
 *
 * Copyright 2019 Jernej Skrabec <jernej.skrabec@siol.net>
 * Copyright 2023 Bootlin
 * Author: Paul Kocialkowski <paul.kocialkowski@bootlin.com>
 */

/*
 * VP8 in Cedrus shares same engine as H264.
 *
 * Note that it seems necessary to call bitstream parsing functions,
 * to parse frame header, otherwise decoded image is garbage. This is
 * contrary to what is driver supposed to do. However, values are not
 * really used, so this might be acceptable. It's possible that bitstream
 * parsing functions set some internal VPU state, which is later necessary
 * for proper decoding. Biggest suspect is "VP8 probs update" trigger.
 */

#include <linux/delay.h>
#include <linux/types.h>
#include <linux/videodev2.h>
#include <media/v4l2-ctrls.h>

#include "cedrus.h"
#include "cedrus_context.h"
#include "cedrus_dec.h"
#include "cedrus_dec_vp8.h"
#include "cedrus_engine.h"
#include "cedrus_proc.h"
#include "cedrus_regs.h"

#define VP8_PROB_HALF 128
#define QUANT_DELTA_COUNT 5

/*
 * This table comes from the concatenation of k_coeff_entropy_update_probs,
 * kf_ymode_prob, default_mv_context, etc. It is provided in this form in
 * order to avoid computing it every time the driver is initialised, and is
 * suitable for direct consumption by the hardware.
 */
static const u8 prob_table_init[] = {
	/* k_coeff_entropy_update_probs */
	/* block 0 */
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0xB0, 0xF6, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xDF, 0xF1, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xF9, 0xFD, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0xFF, 0xF4, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xEA, 0xFE, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0xFF, 0xF6, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xEF, 0xFD, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFE, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0xFF, 0xF8, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFB, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0xFF, 0xFD, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFB, 0xFE, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFE, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0xFF, 0xFE, 0xFD, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFA, 0xFF, 0xFE, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	/* block 1 */
	0xD9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xE1, 0xFC, 0xF1, 0xFD, 0xFF, 0xFF, 0xFE, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xEA, 0xFA, 0xF1, 0xFA, 0xFD, 0xFF, 0xFD, 0xFE,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xDF, 0xFE, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xEE, 0xFD, 0xFE, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0xFF, 0xF8, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xF9, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xF7, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0xFF, 0xFD, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0xFF, 0xFE, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0xFF, 0xFE, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFA, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	/* block 2 */
	0xBA, 0xFB, 0xFA, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xEA, 0xFB, 0xF4, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFB, 0xFB, 0xF3, 0xFD, 0xFE, 0xFF, 0xFE, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0xFF, 0xFD, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xEC, 0xFD, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFB, 0xFD, 0xFD, 0xFE, 0xFE, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0xFF, 0xFE, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFE, 0xFE, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFE, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	/* block 3 */
	0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFA, 0xFE, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xF8, 0xFE, 0xF9, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0xFF, 0xFD, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xF6, 0xFD, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFC, 0xFE, 0xFB, 0xFE, 0xFE, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0xFF, 0xFE, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xF8, 0xFE, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFD, 0xFF, 0xFE, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0xFF, 0xFB, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xF5, 0xFB, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFD, 0xFD, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0xFF, 0xFB, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFC, 0xFD, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xF9, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFA, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	/* kf_y_mode_probs */
	0x91, 0x9C, 0xA3, 0x80, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	/* split_mv_probs */
	0x6E, 0x6F, 0x96, 0x00, 0x00, 0x00, 0x00, 0x00,

	/* bmode_prob */
	0x78, 0x5A, 0x4F, 0x85, 0x57, 0x55, 0x50, 0x6F,
	0x97, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	/* sub_mv_ref_prob */
	0x93, 0x88, 0x12, 0x00,
	0x6A, 0x91, 0x01, 0x00,
	0xB3, 0x79, 0x01, 0x00,
	0xDF, 0x01, 0x22, 0x00,
	0xD0, 0x01, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	/* mv_counts_to_probs */
	0x07, 0x01, 0x01, 0x8F,
	0x0E, 0x12, 0x0E, 0x6B,
	0x87, 0x40, 0x39, 0x44,
	0x3C, 0x38, 0x80, 0x41,
	0x9F, 0x86, 0x80, 0x22,
	0xEA, 0xBC, 0x80, 0x1C,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	/* kf_y_mode_tree */
	0x84, 0x02, 0x04, 0x06, 0x80, 0x81, 0x82, 0x83,

	/* y_mode_tree */
	0x80, 0x02, 0x04, 0x06, 0x81, 0x82, 0x83, 0x84,

	/* uv_mode_tree */
	0x80, 0x02, 0x81, 0x04, 0x82, 0x83, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00,

	/* small_mv_tree */
	0x02, 0x08, 0x04, 0x06, 0x80, 0x81, 0x82, 0x83,
	0x0A, 0x0C, 0x84, 0x85, 0x86, 0x87, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	/* small_mv_tree again */
	0x02, 0x08, 0x04, 0x06, 0x80, 0x81, 0x82, 0x83,
	0x0A, 0x0C, 0x84, 0x85, 0x86, 0x87, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	/* split_mv_tree */
	0x83, 0x02, 0x82, 0x04, 0x80, 0x81, 0x00, 0x00,

	/* b_mode_tree */
	0x80, 0x02, 0x81, 0x04, 0x82, 0x06, 0x08, 0x0C,
	0x83, 0x0A, 0x85, 0x86, 0x84, 0x0E, 0x87, 0x10,
	0x88, 0x89, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	/* submv_ref_tree */
	0x8A, 0x02, 0x8B, 0x04, 0x8C, 0x8D, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	/* mv_ref_tree */
	0x87, 0x02, 0x85, 0x04, 0x86, 0x06, 0x88, 0x89,
};

/*
 * This table is a copy of k_mv_entropy_update_probs from the VP8
 * specification.
 *
 * FIXME: If any other driver uses it, we can consider moving
 * this table so it can be shared.
 */
static const u8 k_mv_entropy_update_probs[2][V4L2_VP8_MV_PROB_CNT] = {
	{ 237, 246, 253, 253, 254, 254, 254, 254, 254,
	  254, 254, 254, 254, 254, 250, 250, 252, 254, 254 },
	{ 231, 243, 245, 253, 254, 254, 254, 254, 254,
	  254, 254, 254, 254, 254, 251, 251, 254, 254, 254 }
};

/* Helpers */

static uint8_t read_bits(struct cedrus_device *dev, unsigned int bits_count,
			 unsigned int probability)
{
	cedrus_write(dev, VE_H264_TRIGGER_TYPE,
		     VE_H264_TRIGGER_TYPE_VP8_GET_BITS |
		     VE_H264_TRIGGER_TYPE_BIN_LENS(bits_count) |
		     VE_H264_TRIGGER_TYPE_PROBABILITY(probability));

	cedrus_poll_cleared(dev, VE_H264_STATUS, VE_H264_STATUS_VLD_BUSY);

	return cedrus_read(dev, VE_H264_BASIC_BITS);
}

/* Context */

static int cedrus_dec_vp8_setup(struct cedrus_context *cedrus_ctx)
{
	struct device *dev = cedrus_ctx->proc->dev->dev;
	struct cedrus_dec_vp8_context *vp8_ctx = cedrus_ctx->engine_ctx;

	vp8_ctx->entropy_probs_buf =
		dma_alloc_coherent(dev, CEDRUS_DEC_VP8_ENTROPY_PROBS_SIZE,
				   &vp8_ctx->entropy_probs_buf_dma,
				   GFP_KERNEL);
	if (!vp8_ctx->entropy_probs_buf)
		return -ENOMEM;

	/*
	 * This offset has been discovered by reverse engineering, we don’t know
	 * what it actually means.
	 */
	memcpy(&vp8_ctx->entropy_probs_buf[2048],
	       prob_table_init, sizeof(prob_table_init));

	return 0;
}

static void cedrus_dec_vp8_cleanup(struct cedrus_context *cedrus_ctx)
{
	struct device *dev = cedrus_ctx->proc->dev->dev;
	struct cedrus_dec_vp8_context *vp8_ctx = cedrus_ctx->engine_ctx;

	dma_free_coherent(dev, CEDRUS_DEC_VP8_ENTROPY_PROBS_SIZE,
			  vp8_ctx->entropy_probs_buf,
			  vp8_ctx->entropy_probs_buf_dma);
}

/* Job */

static int cedrus_dec_vp8_job_prepare(struct cedrus_context *ctx)
{
	struct cedrus_dec_vp8_job *job = ctx->engine_job;
	u32 id;

	id = V4L2_CID_STATELESS_VP8_FRAME;
	job->frame = cedrus_context_ctrl_data(ctx, id);

	return 0;
}

static void get_delta_q(struct cedrus_device *dev)
{
	if (read_bits(dev, 1, VP8_PROB_HALF)) {
		read_bits(dev, 4, VP8_PROB_HALF);
		read_bits(dev, 1, VP8_PROB_HALF);
	}
}

static void process_segmentation_info(struct cedrus_device *dev)
{
	int update, i;

	update = read_bits(dev, 1, VP8_PROB_HALF);

	if (read_bits(dev, 1, VP8_PROB_HALF)) {
		read_bits(dev, 1, VP8_PROB_HALF);

		for (i = 0; i < 4; i++)
			if (read_bits(dev, 1, VP8_PROB_HALF)) {
				read_bits(dev, 7, VP8_PROB_HALF);
				read_bits(dev, 1, VP8_PROB_HALF);
			}

		for (i = 0; i < 4; i++)
			if (read_bits(dev, 1, VP8_PROB_HALF)) {
				read_bits(dev, 6, VP8_PROB_HALF);
				read_bits(dev, 1, VP8_PROB_HALF);
			}
	}

	if (update)
		for (i = 0; i < 3; i++)
			if (read_bits(dev, 1, VP8_PROB_HALF))
				read_bits(dev, 8, VP8_PROB_HALF);
}

static void process_ref_lf_delta_info(struct cedrus_device *dev)
{
	if (read_bits(dev, 1, VP8_PROB_HALF)) {
		int i;

		for (i = 0; i < 4; i++)
			if (read_bits(dev, 1, VP8_PROB_HALF)) {
				read_bits(dev, 6, VP8_PROB_HALF);
				read_bits(dev, 1, VP8_PROB_HALF);
			}

		for (i = 0; i < 4; i++)
			if (read_bits(dev, 1, VP8_PROB_HALF)) {
				read_bits(dev, 6, VP8_PROB_HALF);
				read_bits(dev, 1, VP8_PROB_HALF);
			}
	}
}

static void process_ref_frame_info(struct cedrus_device *dev)
{
	u8 refresh_golden_frame = read_bits(dev, 1, VP8_PROB_HALF);
	u8 refresh_alt_ref_frame = read_bits(dev, 1, VP8_PROB_HALF);

	if (!refresh_golden_frame)
		read_bits(dev, 2, VP8_PROB_HALF);

	if (!refresh_alt_ref_frame)
		read_bits(dev, 2, VP8_PROB_HALF);

	read_bits(dev, 1, VP8_PROB_HALF);
	read_bits(dev, 1, VP8_PROB_HALF);
}

static void cedrus_read_header(struct cedrus_device *dev,
			       const struct v4l2_ctrl_vp8_frame *slice)
{
	int i, j;

	if (V4L2_VP8_FRAME_IS_KEY_FRAME(slice)) {
		read_bits(dev, 1, VP8_PROB_HALF);
		read_bits(dev, 1, VP8_PROB_HALF);
	}

	if (read_bits(dev, 1, VP8_PROB_HALF))
		process_segmentation_info(dev);

	read_bits(dev, 1, VP8_PROB_HALF);
	read_bits(dev, 6, VP8_PROB_HALF);
	read_bits(dev, 3, VP8_PROB_HALF);

	if (read_bits(dev, 1, VP8_PROB_HALF))
		process_ref_lf_delta_info(dev);

	read_bits(dev, 2, VP8_PROB_HALF);

	/* y_ac_qi */
	read_bits(dev, 7, VP8_PROB_HALF);

	/* Parses y_dc_delta, y2_dc_delta, etc. */
	for (i = 0; i < QUANT_DELTA_COUNT; i++)
		get_delta_q(dev);

	if (!V4L2_VP8_FRAME_IS_KEY_FRAME(slice))
		process_ref_frame_info(dev);

	read_bits(dev, 1, VP8_PROB_HALF);

	if (!V4L2_VP8_FRAME_IS_KEY_FRAME(slice))
		read_bits(dev, 1, VP8_PROB_HALF);

	cedrus_write(dev, VE_H264_TRIGGER_TYPE, VE_H264_TRIGGER_TYPE_VP8_UPDATE_COEF);
	/* XXX: check return code */
	cedrus_poll_cleared(dev, VE_H264_STATUS, VE_H264_STATUS_VP8_UPPROB_BUSY);

	cedrus_write(dev, VE_H264_STATUS, VE_H264_STATUS_INT_MASK);

	if (read_bits(dev, 1, VP8_PROB_HALF))
		read_bits(dev, 8, VP8_PROB_HALF);

	if (!V4L2_VP8_FRAME_IS_KEY_FRAME(slice)) {
		read_bits(dev, 8, VP8_PROB_HALF);
		read_bits(dev, 8, VP8_PROB_HALF);
		read_bits(dev, 8, VP8_PROB_HALF);

		if (read_bits(dev, 1, VP8_PROB_HALF)) {
			read_bits(dev, 8, VP8_PROB_HALF);
			read_bits(dev, 8, VP8_PROB_HALF);
			read_bits(dev, 8, VP8_PROB_HALF);
			read_bits(dev, 8, VP8_PROB_HALF);
		}

		if (read_bits(dev, 1, VP8_PROB_HALF)) {
			read_bits(dev, 8, VP8_PROB_HALF);
			read_bits(dev, 8, VP8_PROB_HALF);
			read_bits(dev, 8, VP8_PROB_HALF);
		}

		for (i = 0; i < 2; i++)
			for (j = 0; j < V4L2_VP8_MV_PROB_CNT; j++)
				if (read_bits(dev, 1, k_mv_entropy_update_probs[i][j]))
					read_bits(dev, 7, VP8_PROB_HALF);
	}
}

static void cedrus_vp8_update_probs(const struct v4l2_ctrl_vp8_frame *slice,
				    u8 *prob_table)
{
	int i, j, k;

	memcpy(&prob_table[0x1008], slice->entropy.y_mode_probs,
	       sizeof(slice->entropy.y_mode_probs));
	memcpy(&prob_table[0x1010], slice->entropy.uv_mode_probs,
	       sizeof(slice->entropy.uv_mode_probs));

	memcpy(&prob_table[0x1018], slice->segment.segment_probs,
	       sizeof(slice->segment.segment_probs));

	prob_table[0x101c] = slice->prob_skip_false;
	prob_table[0x101d] = slice->prob_intra;
	prob_table[0x101e] = slice->prob_last;
	prob_table[0x101f] = slice->prob_gf;

	memcpy(&prob_table[0x1020], slice->entropy.mv_probs[0],
	       V4L2_VP8_MV_PROB_CNT);
	memcpy(&prob_table[0x1040], slice->entropy.mv_probs[1],
	       V4L2_VP8_MV_PROB_CNT);

	for (i = 0; i < 4; ++i)
		for (j = 0; j < 8; ++j)
			for (k = 0; k < 3; ++k)
				memcpy(&prob_table[i * 512 + j * 64 + k * 16],
				       slice->entropy.coeff_probs[i][j][k], 11);
}

static int cedrus_dec_vp8_job_configure(struct cedrus_context *cedrus_ctx)
{
	struct cedrus_device *dev = cedrus_ctx->proc->dev;
	struct cedrus_dec_vp8_context *vp8_ctx = cedrus_ctx->engine_ctx;
	struct cedrus_dec_vp8_job *vp8_job = cedrus_ctx->engine_job;
	const struct v4l2_ctrl_vp8_frame *slice = vp8_job->frame;
	dma_addr_t luma_addr, chroma_addr;
	dma_addr_t coded_addr;
	unsigned int coded_size;
	int header_size;
	u32 value;

	cedrus_write(dev, VE_H264_CTRL, VE_H264_CTRL_VP8);

	cedrus_vp8_update_probs(slice, vp8_ctx->entropy_probs_buf);

	value = slice->first_part_size * 8;
	cedrus_write(dev, VE_VP8_FIRST_DATA_PART_LEN, value);

	/* XXX: use defines. */
	header_size = V4L2_VP8_FRAME_IS_KEY_FRAME(slice) ? 10 : 3;

	cedrus_write(dev, VE_VP8_PART_SIZE_OFFSET,
		     slice->first_part_size + header_size);

	cedrus_job_buffer_coded_dma(cedrus_ctx, &coded_addr, &coded_size);

	cedrus_write(dev, VE_H264_VLD_LEN, coded_size * 8);

	/*
	 * FIXME: There is a problem if frame header is skipped (adding
	 * first_part_header_bits to offset). It seems that functions
	 * for parsing bitstreams change internal state of VPU in some
	 * way that can't be otherwise set. Maybe this can be bypassed
	 * by somehow fixing probability table buffer?
	 */
	cedrus_write(dev, VE_H264_VLD_OFFSET, header_size * 8);

	cedrus_write(dev, VE_H264_VLD_END, coded_addr + coded_size);
	cedrus_write(dev, VE_H264_VLD_ADDR,
		     VE_H264_VLD_ADDR_VAL(coded_addr) |
		     VE_H264_VLD_ADDR_FIRST | VE_H264_VLD_ADDR_VALID |
		     VE_H264_VLD_ADDR_LAST);

	cedrus_write(dev, VE_H264_TRIGGER_TYPE,
		     VE_H264_TRIGGER_TYPE_INIT_SWDEC);

	cedrus_write(dev, VE_VP8_ENTROPY_PROBS_ADDR,
		     vp8_ctx->entropy_probs_buf_dma);

	value = 0;
	switch (slice->version) {
	case 1:
		value |= VE_VP8_PPS_FILTER_TYPE_SIMPLE;
		value |= VE_VP8_PPS_BILINEAR_MC_FILTER;
		break;
	case 2:
		value |= VE_VP8_PPS_LPF_DISABLE;
		value |= VE_VP8_PPS_BILINEAR_MC_FILTER;
		break;
	case 3:
		value |= VE_VP8_PPS_LPF_DISABLE;
		value |= VE_VP8_PPS_FULL_PIXEL;
		break;
	}
	if (slice->segment.flags & V4L2_VP8_SEGMENT_FLAG_UPDATE_MAP)
		value |= VE_VP8_PPS_UPDATE_MB_SEGMENTATION_MAP;
	if (!(slice->segment.flags & V4L2_VP8_SEGMENT_FLAG_DELTA_VALUE_MODE))
		value |= VE_VP8_PPS_MB_SEGMENT_ABS_DELTA;
	if (slice->segment.flags & V4L2_VP8_SEGMENT_FLAG_ENABLED)
		value |= VE_VP8_PPS_SEGMENTATION_ENABLE;
	if (vp8_ctx->last_filter_type)
		value |= VE_VP8_PPS_LAST_LOOP_FILTER_SIMPLE;

	value |= VE_VP8_PPS_SHARPNESS_LEVEL(slice->lf.sharpness_level);

	if (slice->lf.flags & V4L2_VP8_LF_FILTER_TYPE_SIMPLE)
		value |= VE_VP8_PPS_LOOP_FILTER_SIMPLE;

	value |= VE_VP8_PPS_LOOP_FILTER_LEVEL(slice->lf.level);

	if (slice->lf.flags & V4L2_VP8_LF_ADJ_ENABLE)
		value |= VE_VP8_PPS_MODE_REF_LF_DELTA_ENABLE;
	if (slice->lf.flags & V4L2_VP8_LF_DELTA_UPDATE)
		value |= VE_VP8_PPS_MODE_REF_LF_DELTA_UPDATE;

	value |= VE_VP8_PPS_TOKEN_PARTITION(ilog2(slice->num_dct_parts));

	if (slice->flags & V4L2_VP8_FRAME_FLAG_MB_NO_SKIP_COEFF)
		value |= VE_VP8_PPS_MB_NO_COEFF_SKIP;

	value |= VE_VP8_PPS_RELOAD_ENTROPY_PROBS;

	if (slice->flags & V4L2_VP8_FRAME_FLAG_SIGN_BIAS_GOLDEN)
		value |= VE_VP8_PPS_GOLDEN_SIGN_BIAS;
	if (slice->flags & V4L2_VP8_FRAME_FLAG_SIGN_BIAS_ALT)
		value |= VE_VP8_PPS_ALTREF_SIGN_BIAS;
	if (vp8_ctx->last_frame_p_type)
		value |= VE_VP8_PPS_LAST_PIC_TYPE_P_FRAME;

	value |= VE_VP8_PPS_LAST_SHARPNESS_LEVEL(vp8_ctx->last_sharpness_level);

	if (!(slice->flags & V4L2_VP8_FRAME_FLAG_KEY_FRAME))
		value |= VE_VP8_PPS_PIC_TYPE_P_FRAME;

	cedrus_write(dev, VE_VP8_PPS, value);

	cedrus_read_header(dev, slice);

	/* Reset registers changed by hardware. */
	cedrus_write(dev, VE_H264_CUR_MB_NUM, 0);
	cedrus_write(dev, VE_H264_MB_ADDR, 0);
	cedrus_write(dev, VE_H264_ERROR_CASE, 0);

	value = VE_VP8_QP_INDEX_DELTA_UVAC(slice->quant.uv_ac_delta) |
		VE_VP8_QP_INDEX_DELTA_UVDC(slice->quant.uv_dc_delta) |
		VE_VP8_QP_INDEX_DELTA_Y2AC(slice->quant.y2_ac_delta) |
		VE_VP8_QP_INDEX_DELTA_Y2DC(slice->quant.y2_dc_delta) |
		VE_VP8_QP_INDEX_DELTA_Y1DC(slice->quant.y_dc_delta) |
		VE_VP8_QP_INDEX_DELTA_BASE_QINDEX(slice->quant.y_ac_qi);

	cedrus_write(dev, VE_VP8_QP_INDEX_DELTA, value);

	value = VE_VP8_FSIZE_WIDTH(slice->width) |
		VE_VP8_FSIZE_HEIGHT(slice->height);

	cedrus_write(dev, VE_VP8_FSIZE, value);

	value = VE_VP8_PICSIZE_WIDTH(slice->width) |
		VE_VP8_PICSIZE_HEIGHT(slice->height);

	cedrus_write(dev, VE_VP8_PICSIZE, value);

	value = VE_VP8_SEGMENT3(slice->segment.quant_update[3]) |
		VE_VP8_SEGMENT2(slice->segment.quant_update[2]) |
		VE_VP8_SEGMENT1(slice->segment.quant_update[1]) |
		VE_VP8_SEGMENT0(slice->segment.quant_update[0]);

	cedrus_write(dev, VE_VP8_SEGMENT_FEAT_MB_LV0, value);

	value = VE_VP8_SEGMENT3(slice->segment.lf_update[3]) |
		VE_VP8_SEGMENT2(slice->segment.lf_update[2]) |
		VE_VP8_SEGMENT1(slice->segment.lf_update[1]) |
		VE_VP8_SEGMENT0(slice->segment.lf_update[0]);

	cedrus_write(dev, VE_VP8_SEGMENT_FEAT_MB_LV1, value);

	value = VE_VP8_LF_DELTA3(slice->lf.ref_frm_delta[3]) |
		VE_VP8_LF_DELTA2(slice->lf.ref_frm_delta[2]) |
		VE_VP8_LF_DELTA1(slice->lf.ref_frm_delta[1]) |
		VE_VP8_LF_DELTA0(slice->lf.ref_frm_delta[0]);

	cedrus_write(dev, VE_VP8_REF_LF_DELTA, value);

	value = VE_VP8_LF_DELTA3(slice->lf.mb_mode_delta[3]) |
		VE_VP8_LF_DELTA2(slice->lf.mb_mode_delta[2]) |
		VE_VP8_LF_DELTA1(slice->lf.mb_mode_delta[1]) |
		VE_VP8_LF_DELTA0(slice->lf.mb_mode_delta[0]);

	cedrus_write(dev, VE_VP8_MODE_LF_DELTA, value);

	/* Destination picture. */

	cedrus_job_buffer_picture_dma(cedrus_ctx, &luma_addr, &chroma_addr);

	cedrus_write(dev, VE_VP8_REC_LUMA, luma_addr);
	cedrus_write(dev, VE_VP8_REC_CHROMA, chroma_addr);

	/* Last frame reference. */

	cedrus_job_buffer_picture_ref_dma(cedrus_ctx, slice->last_frame_ts,
					  &luma_addr, &chroma_addr);

	cedrus_write(dev, VE_VP8_FWD_LUMA, luma_addr);
	cedrus_write(dev, VE_VP8_FWD_CHROMA, chroma_addr);

	/* Golden frame reference. */

	cedrus_job_buffer_picture_ref_dma(cedrus_ctx, slice->golden_frame_ts,
					  &luma_addr, &chroma_addr);

	cedrus_write(dev, VE_VP8_BWD_LUMA, luma_addr);
	cedrus_write(dev, VE_VP8_BWD_CHROMA, chroma_addr);

	/* Alternate reference. */

	cedrus_job_buffer_picture_ref_dma(cedrus_ctx, slice->alt_frame_ts,
					  &luma_addr, &chroma_addr);

	cedrus_write(dev, VE_VP8_ALT_LUMA, luma_addr);
	cedrus_write(dev, VE_VP8_ALT_CHROMA, chroma_addr);

	/* Enable relevant interrupts. */

	cedrus_write(dev, VE_H264_CTRL, VE_H264_CTRL_VP8 |
		     VE_H264_CTRL_DECODE_ERR_INT |
		     VE_H264_CTRL_SLICE_DECODE_INT);

	if (slice->lf.level) {
		vp8_ctx->last_filter_type =
			!!(slice->lf.flags & V4L2_VP8_LF_FILTER_TYPE_SIMPLE);
		vp8_ctx->last_frame_p_type =
			!V4L2_VP8_FRAME_IS_KEY_FRAME(slice);
		vp8_ctx->last_sharpness_level =
			slice->lf.sharpness_level;
	}

	return 0;
}

static void cedrus_dec_vp8_job_trigger(struct cedrus_context *ctx)
{
	struct cedrus_device *dev = ctx->proc->dev;

	cedrus_write(dev, VE_H264_TRIGGER_TYPE,
		     VE_H264_TRIGGER_TYPE_VP8_SLICE_DECODE);
}

/* IRQ */

static int cedrus_dec_vp8_irq_status(struct cedrus_context *ctx)
{
	struct cedrus_device *dev = ctx->proc->dev;
	u32 status;

	status = cedrus_read(dev, VE_H264_STATUS);
	status &= VE_H264_STATUS_INT_MASK;

	if (!status)
		return CEDRUS_IRQ_NONE;

	if  (!(status & VE_H264_CTRL_SLICE_DECODE_INT) ||
	     status & VE_H264_STATUS_VLD_DATA_REQ_INT ||
	     status & VE_H264_STATUS_DECODE_ERR_INT)
		return CEDRUS_IRQ_ERROR;

	return CEDRUS_IRQ_SUCCESS;
}

static void cedrus_dec_vp8_irq_clear(struct cedrus_context *ctx)
{
	struct cedrus_device *dev = ctx->proc->dev;

	cedrus_write(dev, VE_H264_STATUS, VE_H264_STATUS_INT_MASK);
}

static void cedrus_dec_vp8_irq_disable(struct cedrus_context *ctx)
{
	struct cedrus_device *dev = ctx->proc->dev;
	u32 value;

	value = cedrus_read(dev, VE_H264_CTRL);
	value &= ~VE_H264_CTRL_INT_MASK;

	cedrus_write(dev, VE_H264_CTRL, value);
}

/* Engine */

static const struct cedrus_engine_ops cedrus_dec_vp8_ops = {
	.format_prepare		= cedrus_dec_format_coded_prepare,
	.format_configure	= cedrus_dec_format_coded_configure,

	.setup			= cedrus_dec_vp8_setup,
	.cleanup		= cedrus_dec_vp8_cleanup,

	.job_prepare		= cedrus_dec_vp8_job_prepare,
	.job_configure		= cedrus_dec_vp8_job_configure,
	.job_trigger		= cedrus_dec_vp8_job_trigger,

	.irq_status		= cedrus_dec_vp8_irq_status,
	.irq_clear		= cedrus_dec_vp8_irq_clear,
	.irq_disable		= cedrus_dec_vp8_irq_disable,
};

static const struct v4l2_ctrl_config cedrus_dec_vp8_ctrl_configs[] = {
	{
		.id	= V4L2_CID_STATELESS_VP8_FRAME,
	},
};

static const struct v4l2_frmsize_stepwise cedrus_dec_vp8_frmsize = {
	.min_width	= 16,
	.max_width	= 3840,
	.step_width	= 16,

	.min_height	= 16,
	.max_height	= 3840,
	.step_height	= 16,
};

const struct cedrus_engine cedrus_dec_vp8 = {
	.codec			= CEDRUS_CODEC_VP8,
	.role			= CEDRUS_ROLE_DECODER,
	.capabilities		= CEDRUS_CAPABILITY_VP8_DEC,

	.ops			= &cedrus_dec_vp8_ops,

	.pixelformat		= V4L2_PIX_FMT_VP8_FRAME,
	.ctrl_configs		= cedrus_dec_vp8_ctrl_configs,
	.ctrl_configs_count	= ARRAY_SIZE(cedrus_dec_vp8_ctrl_configs),
	.frmsize		= &cedrus_dec_vp8_frmsize,

	.ctx_size		= sizeof(struct cedrus_dec_vp8_context),
	.job_size		= sizeof(struct cedrus_dec_vp8_job),
};
